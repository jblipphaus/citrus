<?xml version="1.0" encoding="UTF-8"?>
<chapter id="templates">
    <title>Templates</title>

    <para>Templates group action sequences to a logical unit. You can think of templates as reusable components
    that are used in several tests. The maintenance is much more effective because the templates are referenced
    several times.</para>
    
    <para>The template always has a unique name. Inside a test case we call the template by this unique name. 
    Have a look at a first example:</para>
  
    <programlisting>
  &lt;template name=&quot;doCreateVariables&quot;&gt;
      &lt;create-variables&gt;
          &lt;variable name=&quot;var&quot; value=&quot;123456789&quot;/&gt;
      &lt;/create-variables&gt;
      
      &lt;call-template name=&quot;doTraceVariables&quot;/&gt;
  &lt;/template&gt;
  
  &lt;template name=&quot;doTraceVariables&quot;&gt;
      &lt;echo&gt;
          &lt;message&gt;Current time is: ${time}&lt;/message&gt;
      &lt;/echo&gt;
      
      &lt;trace-variables/&gt;
  &lt;/template&gt;
    </programlisting>
  
    <para>The code example above describes two template definitions. Templates hold a sequence of test 
    actions or call other templates themselves as seen in the example above.</para>
    
    <note>
      <para>The &lt;call-template&gt; action calls other templates by their name. The called
      template not necessarily has to be located in the same test case XML file. The template might be defined in
      a separate XML file other than the test case itself:</para>
    </note>
    
    <programlisting>
  &lt;testcase name=&quot;templateTest&quot;&gt;
      &lt;variables&gt;
          &lt;variable name=&quot;myTime&quot; value=&quot;citrus:currentDate()&quot;/&gt;
      &lt;/variables&gt;
      &lt;actions&gt;
          &lt;call-template name=&quot;doCreateVariables&quot;/&gt;
          
          &lt;call-template name=&quot;doTraceVariables&quot;&gt;
              &lt;parameter name=&quot;time&quot; value=&quot;${myTime}&quot;&gt;
          &lt;/call-template&gt;
      &lt;/actions&gt;
  &lt;/testcase&gt;
    </programlisting>
    
    <para>There is an open question when dealing with templates that are defined somewhere else outside the test case.
    How to handle variables? A templates may use different variable names then the test and vice versa. But all
    variables must be present with respective values as soon as the template gets called. Otherwise the variables 
    are unknown to the template and the test will raise errors.</para>
    
    <para>So a first approach would be to harmonize variable usage across templates and test cases, so that templates
    and test cases do use the same variable naming. But this approach might lead to high calibration effort. On the 
    other hand a template can handle parameters to solve this problem. When a template is called the calling actor has
    to set some parameters. Lets discuss an example for this issue.</para>
    
    <para>The &quot;doTraceVariables&quot; template uses the variable ${time}. The test case must therefore have a variable
    called time too or declare the variable ${time} as a parameter when calling the template:</para>
    
    <programlisting>
  &lt;call-template name=&quot;doTraceVariables&quot;&gt;
      &lt;parameter name=&quot;time&quot; value=&quot;${myTime}&quot;&gt;
  &lt;/call-template&gt;
    </programlisting>
    
    <para>The variable <emphasis>myTime</emphasis> is translated - if you would call it like this - into the 
    desired <emphasis>time</emphasis> parameter. So the template works fine referencing the time variable. This means
    that you always have to check the used variables inside a template when calling it. There might be a variable that
    is not declared yet inside your test. So you need to define this value as a parameter.</para>
    
</chapter>